# Load required packages - libraries to run the script ####

## Check and install necessary libraries - packages  ####
packagesPrev<- installed.packages()[,"Package"] # Check and get a list of installed packages in this machine and R version
packagesNeed<- c("magrittr", "dplyr" , "this.path", "rjson", "sf", "raster", "pbapply", "ggplot2", "ggpubr", "purrr"); packagesNeed<- packagesNeed[!packagesNeed==""] # Define the list of required packages to run the script
new.packages <- packagesNeed[!(packagesNeed %in% packagesPrev)]; if(length(new.packages)) {install.packages(new.packages, binary=T, force=T, dependencies = F, repos= "https://packagemanager.posit.co/cran/__linux__/jammy/latest")} # Check and install required packages that are not previously installed
packagesRemotes<- c(""); packagesRemotes<- packagesRemotes[!packagesRemotes==""] # Define the list of required packages to run that are avaliable from other sources
new.packagesRemotes <- packagesRemotes[!(packagesRemotes %in% packagesPrev)]; if(length(packagesRemotes)) {lapply(packagesRemotes, function(x) devtools::install_github(x))} # Check and install required packages that are not previously installed

## Load the necessary libraries into the script environment ####
packagesList<-list("magrittr", "terra", "raster", "ggplot2") # Explicitly list the required packages throughout the entire routine. Explicitly listing the required packages throughout the routine ensures that only the necessary packages are listed. Unlike 'packagesNeed', this list includes packages with functions that cannot be directly called using the '::' syntax. By using '::', specific functions or objects from a package can be accessed directly without loading the entire package. Loading an entire package involves loading all the functions and objects 
lapply(packagesList, library, character.only = TRUE)  # Load libraries - packages  


# Set enviroment variables ####

### Define output folder path ####
#### Option 1: Setting for production pipeline purposes. ####
##### This is designed for use in a production environment or workflow.
Sys.setenv(outputFolder = "/path/to/output/folder")

#### Option 2: Recommended for debugging purposes to be used as a testing environment. ####
##### This is designed to facilitate script testing and correction
if ( (!exists("outputFolder"))  ) {
  outputFolder<- {x<- this.path::this.path();  file_prev<-  paste0(gsub("/scripts.*", "/output", x), gsub("^.*/scripts", "", x)  ); options<- tools::file_path_sans_ext(file_prev) %>% {c(., paste0(., ".R"), paste0(., "_R"))}; folder_out<- options %>% {.[file.exists(.)]} %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]}; folder_final<- list.files(folder_out, full.names = T) %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]} }
}

### Define input folder path ####
#### Set the 'input' environment variables. The 'input' environment contains the specified inputs from the ByB platform.
#### The input file 'input.json' is generated by executing the 'Run Script' command in the ByB platform.
input <- rjson::fromJSON(file=file.path(outputFolder, "input.json")) # Load input file

#### Adjusts the input values paths ####
##### This section adjusts the input values based on specific conditions to rectify and prevent errors in the input paths
input<- lapply(input, function(x) { if (!is.null(x) && length(x) > 0 && grepl("/", x) && !grepl("http://", x)  ) { 
  sub("/output/.*", "/output", outputFolder) %>% dirname() %>%  file.path(x) %>% {gsub("//+", "/", .)}  } else{x} }) 


#  Script body ####
## Load grid ####
base_raster<- raster::raster(input$grid_polygon)

## Load Spatial Records ####
spatial_records<- sf::st_read(input$vector_points) %>% sf::st_transform(sf::st_crs(base_raster)$proj4string)
raster_points <- raster::rasterize(spatial_records, base_raster, field = 1) ### Rasterize records ####

## Estimate Spatial Distance Density Map ####
distance_points <- terra::distance(raster_points); 
distance_map<- terra::mask(distance_points, base_raster)

## Estimate tresholds ####
list_thresholds<- c(quantile(distance_map, seq(0.1, 1, 0.1)[1:7]), input$disperssion_distance_m) %>% sort()

data_hipotesis<- data.frame(hipotesis= seq_along(list_thresholds), distance_m= list_thresholds)

## Estimate discrete populations hypotesis ####
  list_hipotesis<- pbapply::pblapply(seq_along(list_thresholds), function(i){
  
    print(i)
    
  threshold <- list_thresholds[i]  #
  distance_threshold<- distance_points; distance_threshold[distance_threshold<=threshold]<- 1; distance_threshold[distance_threshold>threshold]<- 0; 
  distance_mask<- terra::mask(distance_threshold, base_raster) %>% terra::extend(extent(distance_threshold)*2);  distance_mask[is.na(distance_mask)]<- 0
  
  contours<- rasterToContour(distance_mask)
  contours_pols<- sf::st_as_sf(contours) %>%  sf::st_polygonize() %>%  sf::st_buffer(0) %>% 
    terra::vect() %>% terra::aggregate() %>% sf::st_as_sf() %>% sf::st_cast("POLYGON")
  
  distance_matrix <- sf::st_distance(contours_pols)
  dist_object <- as.dist(distance_matrix)
  clustering <- hclust(dist_object, method = "complete")
  contours_pols$pop <- cutree(clustering, h = threshold)
  contours_pols$pop_name <- paste0("pop",  contours_pols$pop)
  final_hipotesis<- cbind(data_hipotesis[i,], contours_pols) %>% sf::st_as_sf()
  list(final_hipotesis_sf= final_hipotesis, 
       final_hipotesis_tif= raster::rasterize(final_hipotesis, base_raster, field = "pop") %>% terra::rast() %>% setNames(unique(paste0("hip", final_hipotesis$hipotesis,"_dist", round(final_hipotesis$distance)))) )

  })
  

list_hipotesis_sf<- purrr::map(list_hipotesis, "final_hipotesis_sf")
list_hipotesis_tif<- purrr::map(list_hipotesis, "final_hipotesis_tif") %>% terra::rast() 

table_hipotesis<- plyr::rbind.fill(list_hipotesis_sf) %>% 
  sf::st_drop_geometry() %>% dplyr::group_by(hipotesis, distance_m) %>% 
  dplyr::summarise(npop= dplyr::n_distinct(pop))



## Plot discrete populations hypotesis ####
plot_results<- pbapply::pblapply(list_hipotesis_sf, function(x)
    { ggplot()+geom_sf(data= x, aes(fill= pop_name))+theme_void()+ggtitle(unique(paste0("hip", x$hipotesis,"_dist", round(x$distance))))+
      theme(base_size = 8, legend.position = "none",
            plot.title = element_text(size = 8))
  }) %>% {ggpubr::ggarrange(plotlist = .)}
  

#  Export results ####
data_hypothesis_path <- file.path(outputFolder, paste0("data_hypothesis", ".csv")) # Define the file path for the 'val_wkt_path' output
write.csv(table_hipotesis, data_hypothesis_path, row.names = F) # write result

plot_hypothesis_path <- file.path(outputFolder, paste0("plot_hypothesis", ".jpg")) # Define the file path for the 'val_wkt_path' output
ggsave(plot_hypothesis_path, plot_results )
  
folder_hypothesis_vector_path<- file.path(outputFolder, "folder_hypothesis_vector_path"); dir.create(folder_hypothesis_vector_path)

lapply(list_hipotesis_sf, function(x) {
  sf::st_write(x, 
               file.path(folder_hypothesis_vector_path, unique(paste0("hip", x$hipotesis,"_dist", round(x$distance), ".GeoJSON"))), delete_dsn= T, driver = "GeoJSON")
})


folder_hypothesis_tif_path<- file.path(outputFolder, "hypothesis_tif_path"); dir.create(folder_hypothesis_tif_path)
layer_paths<-c()
for (i in seq(terra::nlyr(list_hipotesis_tif))) {
  layer_path <- file.path(folder_hypothesis_tif_path, names(list_hipotesis_tif)[[i]] ) %>% paste0(".tif")
  terra::writeRaster(list_hipotesis_tif[[i]], layer_path, overwrite = TRUE ) # write result
  fp <- paste0(layer_path[1])
  layer_paths <- cbind(layer_paths,fp)
}



distance_map_path <- file.path(outputFolder,paste0("distance_map", ".tif"))
terra::writeRaster(distance_map, distance_map_path, overwrite = TRUE ) # write result



# Set Output list ####
output<- list(
  distance_map= distance_map_path,
  data_hypothesis = data_hypothesis_path, 
              plot_hypothesis = plot_hypothesis_path,
              map_hypothesis= layer_paths,
  folder_raster_hypothesis= folder_hypothesis_tif_path,
  folder_polygon_hypothesis= folder_hypothesis_vector_path
  )

# Outputing result to JSON ####
setwd(outputFolder)
jsonData <- rjson::toJSON(output, indent=2)
write(jsonData, file.path(outputFolder,"output.json"))

  