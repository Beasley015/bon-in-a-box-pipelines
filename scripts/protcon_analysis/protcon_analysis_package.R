# Script for analyzing ProtConn with the function
packagesPrev<- installed.packages()[,"Package"] # Check and get a list of installed packages in this machine and R version # nolint
packagesNeed<- list("magrittr", "terra", "sf", "fasterize", "pbapply", "this.path", "rjson", "ggrepel", "remotes", "devtools", "jsonlite", "ggpubr", "Rtools") # Define the list of required packages to run the script # nolint
lapply(packagesNeed, function(x) {   if ( ! x %in% packagesPrev ) { install.packages(x, force=T)}    }) # Check and install required packages that are not previously installed # nolint
library(devtools)
library(remotes)
install_github("connectscape/Makurhini", dependencies = TRUE, upgrade = "always")

# Load libraries
packagesList<-list("magrittr", "terra", "tidyverse", "ggrepel") # Explicitly list the required packages throughout the entire routine. Explicitly listing the required packages throughout the routine ensures that only the necessary packages are listed. Unlike 'packagesNeed', this list includes packages with functions that cannot be directly called using the '::' syntax. By using '::', specific functions or objects from a package can be accessed directly without loading the entire package. Loading an entire package involves loading all the functions and objects 
lapply(packagesList, library, character.only = TRUE)  # Load libraries - packages  

Sys.getenv("SCRIPT_LOCATION")

# The input file 'input.json' is generated by executing the 'Run Script' command in the ByB platform. # nolint
input <- rjson::fromJSON(file=file.path(outputFolder, "input.json")) # Load input file

output<- tryCatch({

 units::units_options(set_units_mode = "standard")
# Load study area shapefile
study_area<- geojsonsf::geojson_sf(input$study_area_polygon) %>% sf::st_transform(input$studyarea_epsg) # load study area and transform using specified epsg

protected_area<- geojsonsf::geojson_sf(input$protected_area_polygon) %>% sf::st_transform(input$studyarea_epsg) # load protected areas and transform using specified epsg
# filter for year
protected_area_filt <- protected_area %>% dplyr::filter(STATUS_YR <= input$years)

protcon_result <- Makurhini::MK_ProtConn(nodes=protected_area_filt, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))

protcon_result.df <- as.data.frame(protcon_result)[c(2,3,4),c(3,4)]

result_plot <- ggplot2::ggplot(protcon_result.df) +
  geom_col(aes(y=Percentage, x=1, fill=`ProtConn indicator`)) +
  coord_polar(theta="y") +
  xlim(c(0, 1.5))+
  geom_text(aes(y=Percentage, x=1, group=`ProtConn indicator`, label=paste0(round(Percentage, 2), "%")), position=position_stack(vjust=0.5))+
  scale_fill_manual(values=c("seagreen4", "seagreen1", "orchid4"))+
  theme_void() +
  theme(text=element_text(color="White"))

# Change in protection over time
# Sequence with start year by interval
years <- seq(from=input$start_year, to=2024, by=input$year_int)

#for (i in 1:nrow(protected_area)) {
#  if(is.na(protected_area$STATUS_YR)) 
#  {protected_area$STATUS_YR <- years[1]}
#  }

# Calculate ProtConn for each specified year
protcon_ts <- function(r){
    protected_area_filt <- protected_area %>% dplyr::filter(STATUS_YR <= r)
    protcon_result <- Makurhini::MK_ProtConn(nodes=protected_area_filt, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
        transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))
    protcon_result.df <- as.data.frame(protcon_result)[c(1,3,4),c(3,4)] %>% mutate(Year=r) 
    return(protcon_result.df)
}

protcon_ts_result <- lapply(years, FUN=protcon_ts)

result_yrs <- bind_rows(protcon_ts_result)
#rotected_area_1950 <- protected_area %>% dplyr::filter(STATUS_YR <= 1950)
#protcon_result_1950 <- Makurhini::MK_ProtConn(nodes=protected_area_1950, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
#transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))
#protcon_result_1950.df <- as.data.frame(protcon_result_1950)[c(1,3,4),c(3,4)] %>% mutate(Year=1950) 

#protected_area_1985 <- protected_area %>% dplyr::filter(STATUS_YR <= 1985)
#protcon_result_1985 <- Makurhini::MK_ProtConn(nodes=protected_area_1985, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
#transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))
#protcon_result_1985.df <- as.data.frame(protcon_result_1985)[c(1,3,4),c(3,4)] %>% mutate(Year=1985) 

#protected_area_2000 <- protected_area %>% dplyr::filter(STATUS_YR <= 2000)
#protcon_result_2000 <- Makurhini::MK_ProtConn(nodes=protected_area_2000, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
#transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))
#protcon_result_2000.df <- as.data.frame(protcon_result_2000)[c(1,3,4),c(3,4)] %>% mutate(Year=2000) 

#protcon_result_2024 <- Makurhini::MK_ProtConn(nodes=protected_area, region=study_area, area_unit=input$unit_distance, distance=list(type=input$distance_matrix_type), probability=0.5, 
#transboundary=input$buffer_zone, distance_thresholds=c(input$distance_threshold))
#protcon_result_2024.df <- as.data.frame(protcon_result_2024)[c(1,3,4),c(3,4)] %>% mutate(Year=2024)

#protcon_result_yrs <- rbind(protcon_result_1950.df, protcon_result_1985.df, protcon_result_2000.df, protcon_result_2024.df)
xint <- input$start_year + 10

result_yrs_plot <- ggplot(result_yrs, aes(x=Year, y=Percentage, group=`ProtConn indicator`, shape=`ProtConn indicator`, color=`ProtConn indicator`))+
geom_point() +
geom_line()+
labs(y="Percent area", x="Year")+
geom_hline(yintercept=30, lty=2)+
annotate("text", x=xint, y=31, label="Kunming-Montreal target")+
geom_hline(yintercept=17, lty=2, color="grey30")+
annotate("text", x=xint, y=18, label="Aichi target", color="grey30")+
geom_line() +
theme_classic()

# Define outputs and output paths
protcon_result_path<- file.path(outputFolder, "protcon_result.csv") # Define the file path for the 'val_wkt_path' output
write.csv(protcon_result[,c(3,4)], protcon_result_path, row.names = F ) # Write the 'val_wkt_path' output

result_plot_path <- file.path(outputFolder, "result_plot.png")
ggsave(result_plot_path, result_plot, dpi=300)

protcon_result_yrs_path <- file.path(outputFolder, "result_plot_yrs.png")
ggsave(protcon_result_yrs_path, result_yrs_plot)


protcon_result_yrs_path2 <- file.path(outputFolder, "result_plot_yrs.csv")
write.csv(result_yrs, protcon_result_yrs_path2, row.names=F)

output<- list(protcon_result = protcon_result_path,
result_plot = result_plot_path, 
result_yrs_plot = protcon_result_yrs_path,
result_yrs = protcon_result_yrs_path2)


}, error = function(e) { list(error= conditionMessage(e)) })

setwd(outputFolder)
jsonlite::write_json(output, "output.json", auto_unbox = TRUE, pretty = TRUE)
